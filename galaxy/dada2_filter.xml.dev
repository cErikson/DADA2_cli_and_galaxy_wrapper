
"${'-q'+ " ".join([str($var.truncQ) for $var in $rep_truncQ] if $rep_truncQ is not None else}


#set repeat_var_8 = \'" "\'.join([ str($var.truncLen) for $var in $repeat_8 ])
-l "$repeat_var_8"


#set repeat_var_9 = \'" "\'.join([ str($var.trimLeft) for $var in $repeat_9 ])
-L "$repeat_var_9"


#set repeat_var_10 = \'" "\'.join([ str($var.maxLen) for $var in $repeat_10 ])
-x "$repeat_var_10"


#set repeat_var_11 = \'" "\'.join([ str($var.minLen) for $var in $repeat_11 ])
-n "$repeat_var_11"


#set repeat_var_12 = \'" "\'.join([ str($var.maxN) for $var in $repeat_12 ])
-N "$repeat_var_12"


#set repeat_var_13 = \'" "\'.join([ str($var.minQ) for $var in $repeat_13 ])
-d "$repeat_var_13"


#set repeat_var_14 = \'" "\'.join([ str($var.maxEE) for $var in $repeat_14 ])
-E "$repeat_var_14"


#if $rm.phix and $rm.phix is not None:
--rm.phix $rm.phix
#end if

#if $primer.fwd and $primer.fwd is not None:
--primer.fwd $primer.fwd
#end if

#if $matchIDs and $matchIDs is not None:
--matchIDs $matchIDs
#end if

#if $id.sep and $id.sep is not None:
--id.sep $id.sep
#end if

#if $id.field and $id.field is not None:
--id.field $id.field
#end if

#if $multithread and $multithread is not None:
--multithread $multithread
#end if

#if $n_reads and $n_reads is not None:
--n_reads $n_reads
#end if

#if $verbose and $verbose is not None:
--verbose $verbose
#end if
]]></command>
  <inputs>
	  
  </repeat>
  <param area="false" argument="--rm.phix" label="(Optional). Default TRUE. If TRUE, discard reads that match against the phiX genome, as determined by isPhiX." name="rm.phix" optional="true" type="text" value="true"/>
  <param area="false" argument="--primer.fwd" label="(Optional). Default NULL. Paired-read filtering only. A character string defining the forward primer. Only allows unambiguous nucleotides. The primer will be compared to the first len(primer.fwd) nucleotides at the start of the read. If there is not an exact match, the read is filtered out. For paired reads, the reverse read is also interrogated, and if the primer is detected on the reverse read, the forward/reverse reads are swapped." name="primer.fwd" optional="true" type="text" value="NULL"/>
  <param area="false" argument="--matchIDs" label="(Optional). Default FALSE. Paired-read filtering only. Whether to enforce matching between the id-line sequence identifiers of the forward and reverse fastq files. If TRUE, only paired reads that share id fields (see below) are output. If FALSE, no read ID checking is done. Note: matchIDs=FALSE essentially assumes matching order between forward and reverse reads. If that matched order is not present future processing steps may break (in particular mergePairs)." name="matchIDs" optional="true" type="text" value="false"/>
  <param area="false" argument="--id.sep" label="(Optional). Default \'\\\\s\' (white-space). Paired-read filtering only. The separator between fields in the id-line of the input fastq files. Passed to the strsplit." name="id.sep" optional="true" type="text" value="\\s"/>
  <param area="false" argument="--id.field" label="(Optional). Default NULL (automatic detection). Paired-read filtering only. The field of the id-line containing the sequence identifier. If NULL (the default) and matchIDs is TRUE, the function attempts to automatically detect the sequence identifier field under the assumption of Illumina formatted output." name="id.field" optional="true" type="text" value="NULL"/>
  <param area="false" argument="--multithread" label="(Optional). Default is FALSE. If TRUE, input files are filtered in parallel via mclapply. If an integer is provided, it is passed to the mc.cores argument of mclapply. Note that the parallelization here is by forking, and each process is loading another fastq file into memory. If memory is an issue, execute in a clean environment and reduce the chunk size n and/or the number of threads." name="multithread" optional="true" type="text" value="false"/>
  <param area="false" argument="--n_reads" label="(Optional). Default 1e5. The number of records (reads) to read in and filter at any one time. This controls the peak memory requirement so that very large fastq files are supported. See FastqStreamer for details." name="n_reads" optional="true" type="text" value="100000.0"/>
  <param area="false" argument="--verbose" label="((Optional). Default TRUE. Whether to output status messages." name="verbose" optional="true" type="text" value="true"/>
</inputs>
<outputs>
	<data format="txt" hidden="false" name=""/>
</outputs>
<help><![CDATA[TODO: Write help]]></help>
</tool>