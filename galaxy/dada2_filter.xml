<tool id="dada2_filter" name="DADA2 filter" version="0.1.0">
    <requirements>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
		#if $single_or_paired.opts == "paired_collection":
		${'&&'.join(('ln -s {} {}'.format(gal, name) for gal,name in zip((x for x in $single_or_paired.fq_input.forward), (x.name for x in $single_or_paired.fq_input.forward))))}
		&&
		${'&&'.join(('ln -s {} {}'.format(gal, name) for gal,name in zip((x for x in $single_or_paired.fq_input.reverse), (x.name for x in $single_or_paired.fq_input.reverse))))}
		#end if
		#if $single_or_paired.opts == "paired":
		${'&&'.join(('ln -s {} {}'.format(gal, name) for gal,name in zip((x for x in $single_or_paired.fwd_fq), (x.name for x in $single_or_paired.fwd_fq))))}
		&&
		${'&&'.join(('ln -s {} {}'.format(gal, name) for gal,name in zip((x for x in $single_or_paired.rev_fq), (x.name for x in $single_or_paired.rev_fq))))}
		#end if
		#if $single_or_paired.opts == "single":
		${'&&'.join(('ln -s {} {}'.format(gal, name) for gal,name in zip((x for x in $single_or_paired.fwd_fq), (x.name for x in $single_or_paired.fwd_fq))))}
		#end if 
		
		&&
		
		dada2_filter.R
		#if $single_or_paired.opts == "paired_collection":
		-f ${' '.join(map(str, (x.name for x in $single_or_paired.fq_input.forward)))}
		-r ${' '.join(map(str, (x.name for x in $single_or_paired.fq_input.reverse)))}
		#else if $single_or_paired.opts == "paired":
		-f ${' '.join(map(str, (x.name for x in $single_or_paired.fwd_fq)))}
		-r ${' '.join(map(str, (x.name for x in $single_or_paired.rev_fq)))}
		#else if $single_or_paired.opts == "single":
		-f ${' '.join(map(str, (x.name for x in $single_or_paired.fwd_fq)))}
		#end if 
		
		#if $sample_names.opts == 'delim':
		-s ${' '.join(map(str, $sample_names.fields))}
		-S $sample_names.delimiter
		#end if
		#if $sample_names.opts == 'regex':
		-R $sample_names.pattern
		#end if 
		
		"${'-q'+ " ".join([str($var.truncQ) for $var in $rep_truncQ] if $rep_truncQ is not None else}
		$rep_truncQ
		
		
    ]]></command>
    <inputs>
		<!-- READ_INPUT -->
		<conditional name="single_or_paired">
			<param name="opts" type="select" label="Is this library mate-paired?">
				<option value="single">Single-end</option>
				<option value="paired">Paired-end</option>
				<option value="paired_collection">Paired-end Dataset Collection</option>
			</param>
			<when value="single">
				<param name="fwd_fq" type="data" format="fastq,fq,fq.gz,fastq.gz,fastqsanger,fastqsanger.gz" multiple= "true" label="FASTQ/FASTA file" help="FASTQ file." />
			</when>
			<when value="paired">
				<param name="fwd_fq" type="data" format="fastq,fq,fq.gz,fastq.gz,fastqsanger,fastqsanger.gz" multiple= "true" label="Mate pair 1" help="FASTQ file." />
				<param name="rev_fq" type="data" format="fastq,fq,fq.gz,fastq.gz,fastqsanger,fastqsanger.gz" multiple= "true" label="Mate pair 2" help="FASTQ file." />
			</when>
			<when value="paired_collection">
				<param name="fq_input" format="fastq,fq,fq.gz,fastq.gz,fastqsanger,fastqsanger.gz" type="data_collection" collection_type="paired,list:paired" label="FASTQ Paired Dataset" help="" />
			</when>
		</conditional>
		<!-- SAMPLE NAMING -->
		<conditional name="sample_names">
			<param name="opts" type="select" label="How to extract file names">
				<option value="none">Keep full file name</option>
				<option value="delim">Select delimited field</option>
				<option value="regex">Use regex</option>
			</param>
			<when value="none">
			</when>
			<when value="delim">
				<param name="fields" type="text" multiple="true" value= "1 2 3" label="Fields to select" />
				<param name="delim" type="text" value="_" label="Field delimiter" help="FASTQ file." />
			</when>
			<when value="regex">
				<param name="regex" type="text" help="" />
			</when>
		</conditional>
		
		<repeat min="0" max="2" name="rep_truncq" title="Truncate Quality">
			<param argument="--truncQ" label="Truncate Quality" help="(Optional). Default 2. Truncate reads at the first instance of a quality score less than or equal to truncQ." name="truncQ" type="integer" value="2" min="0" max="40" />
		</repeat>
		
		<repeat min="0" max="2" name="rep_truncLen" title="Truncate Length">
			<param argument="--truncLen" label="Truncate Length" help="(Optional). Default 0 (no truncation). Truncate reads after truncLen bases. Reads shorter than this are discarded." name="truncLen" optional="true" type="text" value="0"/>
		</repeat>
		
		<repeat min="0" max="2" name="rep_trimLeft" title="Truncate Quality">
			<param argument="--trimLeft" label="Truncate Quality" help="(Optional). Default 0. The number of nucleotides to remove from the start of each read. If both truncLen and trimLeft are provided, filtered reads will have length truncLen-trimLeft." name="trimLeft" optional="true" type="text" value="0"/>
		</repeat>
		
		<repeat min="0" max="2" name="rep_maxLen" title="Maximum Length">
			<param argument="--maxLen" label="Maximum Length" help="(Optional). Default Inf (no maximum). Remove reads with length greater than maxLen. maxLen is enforced before trimming and truncation." name="maxLen" optional="true" type="text" value="Inf"/>
		</repeat>
		
		<repeat min="0" max="2" name="rep_minLen" title="Minimum Length">
			<param argument="--minLen" label="Minimum Length" help="(Optional). Default 20. Remove reads with length less than minLen. minLen is enforced after trimming and truncation." name="minLen" optional="true" type="text" value="20"/>
		</repeat>
		
		<repeat min="0" max="2" name="rep_manN" title="Maximum Ns">
			<param argument="--maxN" label="Maximum Ns" help="(Optional). Default 0. After truncation, sequences with more than maxN Ns will be discarded. Note that dada does not allow Ns." name="maxN" optional="true" type="text" value="0"/>
		</repeat>
		
		<repeat min="0" max="2" name="rep_minQ" title="Minimum Base Quality">
			<param argument="--minQ" label="Minimum Base Quality" help="(Optional). Default 0. After truncation, reads contain a quality score less than minQ will be discarded." name="minQ" optional="true" type="text" value="0"/>
		</repeat>
			
		<repeat min="0" max="2" name="rep_maxEE" title="Maximum Expected Error">
			<param argument="--maxEE" label="maxEE" help="(Optional). Default Inf (no EE filtering). Two are needed for pairedend. vaules After truncation, reads with higher than maxEE \'expected errors\' will be discarded. Expected errors are calculated from the nominal definition of the quality score: EE = sum(10^(-Q/10))" name="maxEE" optional="true" type="text" value="Inf"/>
		</repeat>
    </inputs>
    <outputs>
		<collection name="filtered_R1" type="list" label="${tool.name} on ${on_string}: description">
			<discover_datasets pattern=".*R1-filtered.fastq.gz"  visible="true" format="fastqsanger"/>
		</collection>
		<collection name="filtered_R2" type="list" label="${tool.name} on ${on_string}: description">
			<filter> single_or_paired['opts'] == "paired" or single_or_paired['opts'] == "paired_collection" </filter>
			<discover_datasets pattern=".*R2-filtered.fastq.gz"  visible="true" format="fastqsanger"/>
		</collection>
    </outputs>
    <help><![CDATA[
        TODO: Fill in help.
    ]]></help>
</tool>
